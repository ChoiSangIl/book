
## 데이터 모델과 질의 언어
### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
- 애플리케이션 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다
  - 관계형 기법은 다루기 힘든 스키마와 불필요한 애플리케이션 코드를 발생 시킨다.
- 문서 모델의 미흡한 조인 지원은 애플리케이션에 따라 문제일 수도 있고 아닐 수도 있다.
  - 어떤 시점에 발생한 이벤트를 기록하는 문서 데이터베이스를 사용하는 분석 애플리케이션에서는 다대다 관계가 결코 필요하지 않다.
- 애플리케이션에서 다대다 관계를 사용한다면 문서 모델의 매력이 떨어진다.
  - 비정규화로 조인의 필요성을 줄이기가 가능하지만 애플리케이션 코드는 비정규화된 데이터의 일관성을 유지하기 위해 추가작업을 해야 한다. 
    - **복잡도가 애플리케이션으로 이동할 뿐만 아니라 보통 데이터베이스 내 특화된 코드로 수행되는 조인보다 더 느리다. 이런 경우 문서 모델을 사용하는 것은 훨씬 더 복잡한 애플리케이션 코드와 나쁜 성능으로 이어질 수 있다**

> 일반적으로 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지 말할 수 없다. **데이터 항목 간에 존재하는 관계 유형에 따라 다르다** 상호 연결이 많은 데이터의 경우 문서 모델은 곤란하지만 관계형 모델은 무난하며 자연 스럽다.

### 문서 모델에서의 스키마 유연성
문서 데이터베이스는 종종 스키마리스(schemaless)로 불리지만 이는 오해의 소지가 있다.  
왜? 데이터를 읽는 코드는 보통 구조의 유형을 어느 정도 가정한다 -> 즉 암묵적인 스키마가 있지만 데이터 베이스는 이를 강요하지 않는다.
- 쓰기 스키마 (schema-on-write) -> 디비는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장
- 읽기 스키마 (schema-on-read) -> 데이터 구조는 암묵적이고 데이터를 읽을 때만 해석

읽기 스키마는 동적 타입과 유사하고 쓰기 스키마는 정적 타입과 비슷함  
언어 타입도 논쟁이 많듯이 데이터베이스 스키마 또한 논쟁이 많은 주제이다. 옳고 그른 정단은 없다.  

2개의 접근 방식의 차이는 데이터 타입을 변경하고자 할 때 뚜렷이 나타난다.  
ex) 하나의 필드에 사용자 전체 이름을 저장하고 있지만 성과 이름을 분리해서 저장하고 싶다고 가정  
문서 데이터베이스는 읽은 경우 처리하는 코드만 있으면 된다.
```
if(user && user.name && !user.first_name){
  // 2013년 12월 8일 이전에 쓴 문서는 first_name이 없음
  user.first_name = user.name.split(" ")[0]
}
```
반면 정적 타입의 데이터베이스 스키마에서는 보통 다음과 같이 마이그레이션을 수행한다.
```
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1); -- 포스트그레스큐엘
UPDATE users SET first_name = substring_index(name, ' ', 1); --마이 SQL
```
스키마 변경은 느리고 중단시간을 요구한다. (하지만 대부분 관계형 데이터베이스의 alter table은 밀리초 안에 수행됨)  

- 읽기 스키마 접근 방식(문서 디비)는 어떤 이유로 컬렉션 안의 항목이 모두 동일한 구조가 아닐 때 유리하다.
  - 다른 여러 유형의 오브젝트가 있고 각 유형을 자체 테이블에 넣는 방법은 실용적이지 않다.
  - 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다. 

하지만 모든 레코드가 동일한 구조라고 예상된다면 읽기 스키마가 구조를 강제하기 위한 유용한 메커니즘이다.

